--
-- Autogenerated by Thrift
--
-- DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
-- @generated
--


require 'Thrift'
require 'Demo_constants'

Type = {
  ADD = 1,
  SUBTRACT = 2,
  MULTIPLY = 3,
  DIVIDE = 4
}

Work = __TObject:new{
  num1,
  num2,
  type,
  comment,
  key
}

function Work:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.I32 then
        self.num1 = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.I64 then
        self.num2 = iprot:readI64()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.I32 then
        self.type = iprot:readI32()
      else
        iprot:skip(ftype)
      end
    elseif fid == 4 then
      if ftype == TType.STRING then
        self.comment = iprot:readString()
      else
        iprot:skip(ftype)
      end
    elseif fid == 5 then
      if ftype == TType.STRING then
        self.key = iprot:readString()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function Work:write(oprot)
  oprot:writeStructBegin('Work')
  if self.num1 ~= nil then
    oprot:writeFieldBegin('num1', TType.I32, 1)
    oprot:writeI32(self.num1)
    oprot:writeFieldEnd()
  end
  if self.num2 ~= nil then
    oprot:writeFieldBegin('num2', TType.I64, 2)
    oprot:writeI64(self.num2)
    oprot:writeFieldEnd()
  end
  if self.type ~= nil then
    oprot:writeFieldBegin('type', TType.I32, 3)
    oprot:writeI32(self.type)
    oprot:writeFieldEnd()
  end
  if self.comment ~= nil then
    oprot:writeFieldBegin('comment', TType.STRING, 4)
    oprot:writeString(self.comment)
    oprot:writeFieldEnd()
  end
  if self.key ~= nil then
    oprot:writeFieldBegin('key', TType.STRING, 5)
    oprot:writeString(self.key)
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end

Worker = __TObject:new{
  works,
  result,
  work_map
}

function Worker:read(iprot)
  iprot:readStructBegin()
  while true do
    local fname, ftype, fid = iprot:readFieldBegin()
    if ftype == TType.STOP then
      break
    elseif fid == 1 then
      if ftype == TType.LIST then
        self.works = {}
        local _etype3, _size0 = iprot:readListBegin()
        for _i=1,_size0 do
          local _elem4 = Work:new{}
          _elem4:read(iprot)
          table.insert(self.works, _elem4)
        end
        iprot:readListEnd()
      else
        iprot:skip(ftype)
      end
    elseif fid == 2 then
      if ftype == TType.DOUBLE then
        self.result = iprot:readDouble()
      else
        iprot:skip(ftype)
      end
    elseif fid == 3 then
      if ftype == TType.MAP then
        self.work_map = {}
        local _ktype6, _vtype7, _size5 = iprot:readMapBegin() 
        for _i=1,_size5 do
          local _key9 = iprot:readString()
          local _val10 = Work:new{}
          _val10:read(iprot)
          self.work_map[_key9] = _val10
        end
        iprot:readMapEnd()
      else
        iprot:skip(ftype)
      end
    else
      iprot:skip(ftype)
    end
    iprot:readFieldEnd()
  end
  iprot:readStructEnd()
end

function Worker:write(oprot)
  oprot:writeStructBegin('Worker')
  if self.works ~= nil then
    oprot:writeFieldBegin('works', TType.LIST, 1)
    oprot:writeListBegin(TType.STRUCT, #self.works)
    for _,iter11 in ipairs(self.works) do
      iter11:write(oprot)
    end
    oprot:writeListEnd()
    oprot:writeFieldEnd()
  end
  if self.result ~= nil then
    oprot:writeFieldBegin('result', TType.DOUBLE, 2)
    oprot:writeDouble(self.result)
    oprot:writeFieldEnd()
  end
  if self.work_map ~= nil then
    oprot:writeFieldBegin('work_map', TType.MAP, 3)
    oprot:writeMapBegin(TType.STRING, TType.STRUCT, ttable_size(self.work_map))
    for kiter12,viter13 in pairs(self.work_map) do
      oprot:writeString(kiter12)
      viter13:write(oprot)
    end
    oprot:writeMapEnd()
    oprot:writeFieldEnd()
  end
  oprot:writeFieldStop()
  oprot:writeStructEnd()
end